문제 회고를 위해 알고리즘 풀이 기록을 남깁니다.

# 백준 문제번호 문제제목
[6068 시간 관리하기](https://www.acmicpc.net/problem/6068)

### 문제 이해하기
일을 하는데 [걸리는시간, 끝내야 하는 시간]의 데이터가 N개만큼 들어올 때 가장 늦게
일을 시작해도 되는 시간을 구하는 문제.
 

### 문제 접근 방법
1. 처음에는 그리디적인 접근으로 풀려고 했었다.
가장 늦게 일어나도 되는 시간을 "끝내야 하는 시간 - 걸리는 시간"중 가장 작은 수를
정답의 근사치로 선택하였고, 동시에 2개 이상의 일을 병렬적으로 수행할 수 없기 때문에
이를 기반으로 스케줄이 겹치는 시간을 골라서 겹치는만큼 정답의 근사치에서 빼주었다.
(겹치는 시간만큼 시간이 더 소요될것이기 때문)

하지만, 오답이 나왔다. 반례는 찾지 못했다..

2. 두번째로 완전탐색을 고려했다.
초기에는 하루의 시작인 t를 0으로 설정하고, 끝내야 하는 시간의 오름차순으로 정렬한 데이터를
기반으로 모든 데이터를 반복하면서 소요 시간을 계속해서 t에 더해주었고 만약 해당 걸리는 시간에 매핑되는
종료시간보다 t 값이 커지면 그 이전 t값이 정답이 된다.

이 방법은 항상 최적의 해를 보장하지만, 걸리는 시간이 1000, 끝내야 하는 시간이 100만의
입력이 들어오기 때문에 t를 0부터 시작하여 100만까지 반복하면 100만 * 1000 ==> 10억 가량의 시간복잡도가
소요되고, 이는 시간초과가 발생한다.

3. 시간을 단축하기 위해 이진탐색을 고려하였다.
결국 t의 범위는 (0 ~ 가장 큰 종료시간)이기 때문에 즉, t는 정렬 되어있기 때문에
이진탐색을 적용할 수 있다. 2번에서 t를 1씩 계속 더해주었던 방법에서
이진탐색으로 t 시작점을 정해주어서 문제를 해결하였다.


### 구현 배경 지식
1. 이진탐색



### 접근 방법을 적용한 코드
```python
def binary_search(arr, start, end):
    res = -1
    while start <= end:
        mid = (start + end) // 2

        temp = mid
        fail = False
        for i in range(N):
            temp += arr[i][0]
            if temp > arr[i][1]:
                fail = True
                break

        if fail:
            end = mid - 1
        else:
            res = mid
            start = mid + 1

    return res


N = int(input())

arr = []
for i in range(N):
    arr.append(list(map(int, input().split())))

end = -1
for i in range(N):
    end = max(end, arr[i][1])

arr.sort(key=lambda x: x[1])

answer = binary_search(arr, 0, end)
print(answer)

```

